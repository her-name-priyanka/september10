<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Starlight Headliner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #000;
            margin: 0;
            overflow: hidden;
            cursor: crosshair;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .star {
            position: absolute;
            background-color: #fff;
            border-radius: 50%;
            opacity: 0;
            animation: twinkle linear infinite;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }

        /* Button styling */
        #audioControl {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid white;
            color: white;
            padding: 10px 16px;
            border-radius: 8px;
            font-family: sans-serif;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.3s;
        }

        #audioControl:hover {
            background: rgba(255, 255, 255, 0.25);
        }
    </style>
</head>
<body class="bg-gray-950">
    <canvas id="starlightCanvas"></canvas>

    <!-- Background Music -->
    <audio id="bgMusic" loop>
        <source src="./night ambient.m4a" type="audio/mpeg">
    </audio>

    <!-- Mute/Unmute Button -->
    <button id="audioControl">ðŸ”Š Mute</button>

    <script>
        const canvas = document.getElementById('starlightCanvas');
        const ctx = canvas.getContext('2d');
        let stars = [];
        let shootingStars = [];
        let particles = [];
        let specialStar = null;
        let isConstellationActive = false;
        let constellationPoints = [];
        const STAR_COUNT = 2500;
        const SHOOTING_STAR_CHANCE = 0.005;
        const PARTICLE_COUNT = 15;

        const starColors = ['#FFFFFF', '#FDF5E6', '#ADD8E6', '#B0E0E6', '#E6E6FA', '#87CEEB', '#9370DB', '#DA70D6', '#FFC0CB'];
        const specialStarColor = '#FF1493';

        function Star(isSpecial = false) {
            this.x = Math.random() * canvas.width;
            this.y = Math.random() * canvas.height;
            this.size = isSpecial ? 6 : Math.random() * 2;
            this.opacity = Math.random();
            this.twinkleSpeed = Math.random() * 0.015 + 0.002;
            this.twinkleDirection = Math.random() > 0.5 ? 1 : -1;
            this.color = isSpecial ? specialStarColor : starColors[Math.floor(Math.random() * starColors.length)];
            this.isSpecial = isSpecial;
        }

        function ShootingStar() {
            this.x = Math.random() * canvas.width;
            this.y = Math.random() * canvas.height;
            this.length = Math.random() * 150 + 80;
            this.speed = Math.random() * 5 + 3;
            this.angle = Math.PI * 2 * Math.random();
            this.opacity = 1;
            this.life = this.length / this.speed;
        }

        function Particle(x, y) {
            this.x = x;
            this.y = y;
            this.size = Math.random() * 1.5 + 0.5;
            this.opacity = 1;
            this.vx = (Math.random() - 0.5) * 0.5;
            this.vy = (Math.random() - 0.5) * 0.5;
        }

        function defineConstellationPoints() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const scale = Math.min(canvas.width, canvas.height) * 0.1;

            constellationPoints = [
                { x: centerX - scale * 3, y: centerY - scale, letter: 'P' },
                { x: centerX - scale * 3, y: centerY + scale * 0.5 },
                { x: centerX - scale * 2, y: centerY + scale * 0.5 },
                { x: centerX - scale * 2, y: centerY - scale },
                { x: centerX - scale * 2.5, y: centerY - scale * 0.25 },
                { x: centerX - scale * 3, y: centerY - scale * 0.25 },
                { x: centerX - scale * 1.5, y: centerY - scale, letter: 'R' },
                { x: centerX - scale * 1.5, y: centerY + scale * 0.5 },
                { x: centerX - scale * 1, y: centerY + scale * 0.5 },
                { x: centerX - scale * 1, y: centerY - scale },
                { x: centerX - scale * 1.25, y: centerY - scale * 0.25 },
                { x: centerX - scale * 1.5, y: centerY - scale * 0.25 },
                { x: centerX - scale * 0.5, y: centerY - scale, letter: 'I' },
                { x: centerX - scale * 0.5, y: centerY + scale * 0.5 },
                { x: centerX + scale * 0.25, y: centerY - scale, letter: 'Y' },
                { x: centerX + scale * 0.5, y: centerY - scale * 0.25 },
                { x: centerX + scale * 0.75, y: centerY - scale },
                { x: centerX + scale * 0.5, y: centerY + scale * 0.5 },
                { x: centerX + scale * 1.25, y: centerY, letter: 'A' },
                { x: centerX + scale * 1.5, y: centerY - scale },
                { x: centerX + scale * 1.75, y: centerY },
                { x: centerX + scale * 1.25, y: centerY - scale * 0.5 },
                { x: centerX + scale * 1.75, y: centerY - scale * 0.5 },
                { x: centerX + scale * 2.25, y: centerY, letter: 'N' },
                { x: centerX + scale * 2.25, y: centerY - scale },
                { x: centerX + scale * 2.75, y: centerY + scale * 0.5 },
                { x: centerX + scale * 2.75, y: centerY - scale },
                { x: centerX + scale * 3.25, y: centerY - scale, letter: 'K' },
                { x: centerX + scale * 3.25, y: centerY + scale * 0.5 },
                { x: centerX + scale * 3.75, y: centerY - scale * 0.25 },
                { x: centerX + scale * 3.25, y: centerY - scale * 0.25 },
                { x: centerX + scale * 3.75, y: centerY + scale * 0.5 },
                { x: centerX + scale * 4.25, y: centerY, letter: 'A' },
                { x: centerX + scale * 4.5, y: centerY - scale },
                { x: centerX + scale * 4.75, y: centerY },
                { x: centerX + scale * 4.25, y: centerY - scale * 0.5 },
                { x: centerX + scale * 4.75, y: centerY - scale * 0.5 }
            ];
        }

        function createInitialStars() {
            stars = [];
            specialStar = new Star(true);
            stars.push(specialStar);
            for (let i = 0; i < STAR_COUNT; i++) {
                stars.push(new Star());
            }
        }

        function drawConstellation() {
            if (!isConstellationActive) return;
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 1.5;
            ctx.beginPath();

            const letters = {
                'P': [0, 1, 2, 3, 4, 5],
                'R': [6, 7, 8, 9, 10, 11],
                'I': [12, 13],
                'Y': [14, 15, 16, 15, 17],
                'A1': [18, 19, 20, 21, 22],
                'N': [23, 24, 25, 26],
                'K': [27, 28, 29, 30, 31],
                'A2': [32, 33, 34, 35, 36]
            };

            const drawLetter = (points) => {
                ctx.moveTo(constellationPoints[points[0]].x, constellationPoints[points[0]].y);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(constellationPoints[points[i]].x, constellationPoints[points[i]].y);
                }
            };
            
            drawLetter(letters.P);
            drawLetter(letters.R);
            drawLetter(letters.I);
            drawLetter(letters.Y);
            drawLetter(letters.A1);
            drawLetter(letters.N);
            drawLetter(letters.K);
            drawLetter(letters.A2);
            ctx.stroke();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            stars.forEach(star => {
                ctx.fillStyle = `rgba(${parseInt(star.color.substring(1, 3), 16)}, ${parseInt(star.color.substring(3, 5), 16)}, ${parseInt(star.color.substring(5, 7), 16)}, ${star.opacity})`;
                if (star.isSpecial) {
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = star.color;
                }
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
                if (star.isSpecial) ctx.shadowBlur = 0;

                star.opacity += star.twinkleSpeed * star.twinkleDirection;
                if (star.opacity <= 0.2 || star.opacity >= 1) {
                    star.twinkleDirection *= -1;
                }
            });

            drawConstellation();

            if (Math.random() < SHOOTING_STAR_CHANCE) {
                shootingStars.push(new ShootingStar());
            }

            for (let i = shootingStars.length - 1; i >= 0; i--) {
                const s = shootingStars[i];
                ctx.strokeStyle = `rgba(255, 255, 255, ${s.opacity})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(s.x, s.y);
                s.x += Math.cos(s.angle) * s.speed;
                s.y += Math.sin(s.angle) * s.speed;
                ctx.lineTo(s.x, s.y);
                ctx.stroke();
                s.opacity -= 0.01;
                s.life--;
                if (s.life <= 0 || s.x < -100 || s.x > canvas.width + 100 || s.y < -100 || s.y > canvas.height + 100) {
                    shootingStars.splice(i, 1);
                }
            }
            
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                ctx.fillStyle = `rgba(255, 255, 255, ${p.opacity})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                p.x += p.vx;
                p.y += p.vy;
                p.opacity -= 0.03;
                p.size -= 0.02;
                if (p.opacity <= 0 || p.size <= 0) {
                    particles.splice(i, 1);
                }
            }
            requestAnimationFrame(draw);
        }

        function handleResize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            createInitialStars();
            defineConstellationPoints();
            isConstellationActive = false;
        }

        function handleMouseMove(event) {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                particles.push(new Particle(event.clientX, event.clientY));
            }
        }
        
        function handleMouseClick(event) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            const dist = Math.sqrt((mouseX - specialStar.x)**2 + (mouseY - specialStar.y)**2);
            if (dist <= specialStar.size) {
                isConstellationActive = !isConstellationActive;
            }
        }

        window.onload = () => {
            handleResize();
            draw();
        };

        window.addEventListener('resize', handleResize);
        window.addEventListener('mousemove', handleMouseMove);
        window.addEventListener('click', handleMouseClick);

        // ðŸŽµ Music Control
        const bgMusic = document.getElementById('bgMusic');
        const audioControl = document.getElementById('audioControl');
        let isMuted = false;

        // Start music only after user clicks anywhere (browser policy)
        document.body.addEventListener('click', () => {
            if (bgMusic.paused) {
                bgMusic.play().catch(() => {});
            }
        }, { once: true });

        audioControl.addEventListener('click', () => {
            if (isMuted) {
                bgMusic.muted = false;
                audioControl.textContent = "ðŸ”Š Mute";
            } else {
                bgMusic.muted = true;
                audioControl.textContent = "ðŸ”‡ Unmute";
            }
            isMuted = !isMuted;
        });
    </script>
</body>
</html>
